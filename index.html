<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>å·¦å³æ³¢å½¢ï¼†ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ é‡ã­è¡¨ç¤ºï¼ˆå·®ç•°è‰²ä»˜ãï¼‰</title>
  <style>
    body {
      background: #222;
      color: white;
      font-family: sans-serif;
      padding: 20px;
    }
    canvas {
      width: 100%;
      height: 200px;
      background: #000;
      margin: 10px 0;
      display: block;
    }
    .controls {
      margin: 10px 0;
    }
    input[type="range"] {
      width: 100%;
    }
    label {
      display: block;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <h2>ğŸ§ å·¦å³æ³¢å½¢ï¼†ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ  é‡ã­è¡¨ç¤ºï¼ˆå·®ç•°è‰²ï¼‰</h2>
  <input type="file" id="fileInput" accept="video/mp4,audio/wav" />
  <div class="controls">
    <button id="play">â–¶ å†ç”Ÿ</button>
    <input type="range" id="seekBar" min="0" max="1" step="0.001" value="0" />
  </div>

  <h3>ğŸ”Š æ³¢å½¢ï¼ˆå·¦å³é‡ã­ï¼‰</h3>
  <canvas id="waveformCanvas" width="800" height="200"></canvas>

  <h3>ğŸ”Š ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ï¼ˆå·¦å³å·®ç•°è‰²ä»˜ãï¼‰</h3>
  <canvas id="spectrogramCanvas" width="800" height="200"></canvas>

  <label>å·¦éŸ³é‡ï¼š<input type="range" id="leftVolume" min="0" max="1" step="0.01" value="1"></label>
  <label>å³éŸ³é‡ï¼š<input type="range" id="rightVolume" min="0" max="1" step="0.01" value="1"></label>

<script>
  const fileInput = document.getElementById("fileInput");
  const playButton = document.getElementById("play");
  const seekBar = document.getElementById("seekBar");
  const waveformCanvas = document.getElementById("waveformCanvas");
  const spectrogramCanvas = document.getElementById("spectrogramCanvas");
  const waveformCtx = waveformCanvas.getContext("2d");
  const spectrogramCtx = spectrogramCanvas.getContext("2d");
  const leftVolume = document.getElementById("leftVolume");
  const rightVolume = document.getElementById("rightVolume");

  let audioContext = new (window.AudioContext || window.webkitAudioContext)();
  let leftBuffer = null;
  let rightBuffer = null;
  let startTime = 0;
  let pauseOffset = 0;
  let duration = 0;
  let playing = false;

  let leftGainNode, rightGainNode;
  let leftAnalyser, rightAnalyser;
  let leftSource, rightSource;

  fileInput.addEventListener("change", async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    const arrayBuffer = await file.arrayBuffer();
    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

    if (audioBuffer.numberOfChannels < 2) {
      alert("ã‚¹ãƒ†ãƒ¬ã‚ªéŸ³å£°ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼");
      return;
    }

    const leftData = audioBuffer.getChannelData(0);
    const rightData = audioBuffer.getChannelData(1);

    leftBuffer = audioContext.createBuffer(1, leftData.length, audioBuffer.sampleRate);
    rightBuffer = audioContext.createBuffer(1, rightData.length, audioBuffer.sampleRate);
    leftBuffer.copyToChannel(leftData, 0);
    rightBuffer.copyToChannel(rightData, 0);

    duration = leftBuffer.duration;
    seekBar.max = duration;

    drawWaveformCombined(waveformCtx, leftData, rightData);
    alert("èª­ã¿è¾¼ã¿å®Œäº†ï¼");
  });

  playButton.addEventListener("click", () => {
    if (!leftBuffer || !rightBuffer) return alert("ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„");

    if (playing) {
      stopPlayback();
      playButton.textContent = "â–¶ å†ç”Ÿ";
    } else {
      startPlayback(pauseOffset);
      playButton.textContent = "â¸ ä¸€æ™‚åœæ­¢";
    }
  });

  function startPlayback(offset) {
    leftSource = audioContext.createBufferSource();
    rightSource = audioContext.createBufferSource();
    leftSource.buffer = leftBuffer;
    rightSource.buffer = rightBuffer;

    leftGainNode = audioContext.createGain();
    rightGainNode = audioContext.createGain();
    leftGainNode.gain.value = parseFloat(leftVolume.value);
    rightGainNode.gain.value = parseFloat(rightVolume.value);

    leftAnalyser = audioContext.createAnalyser();
    rightAnalyser = audioContext.createAnalyser();
    leftAnalyser.fftSize = 256;
    rightAnalyser.fftSize = 256;

    const merger = audioContext.createChannelMerger(2);
    leftSource.connect(leftGainNode).connect(leftAnalyser).connect(merger, 0, 0);
    rightSource.connect(rightGainNode).connect(rightAnalyser).connect(merger, 0, 1);
    merger.connect(audioContext.destination);

    startTime = audioContext.currentTime - offset;
    leftSource.start(0, offset);
    rightSource.start(0, offset);
    playing = true;

    requestAnimationFrame(updateSeekBar);
    requestAnimationFrame(drawSpectrogramCombined);

    leftSource.onended = stopPlayback;
  }

  function stopPlayback() {
    if (leftSource) leftSource.stop();
    if (rightSource) rightSource.stop();
    pauseOffset = audioContext.currentTime - startTime;
    playing = false;
    playButton.textContent = "â–¶ å†ç”Ÿ";
  }

  function updateSeekBar() {
    if (!playing) return;
    const current = audioContext.currentTime - startTime;
    seekBar.value = current;
    if (current >= duration) {
      playing = false;
      playButton.textContent = "â–¶ å†ç”Ÿ";
      return;
    }
    requestAnimationFrame(updateSeekBar);
  }

  seekBar.addEventListener("input", () => {
    if (playing) {
      stopPlayback();
      pauseOffset = parseFloat(seekBar.value);
      startPlayback(pauseOffset);
    } else {
      pauseOffset = parseFloat(seekBar.value);
    }
  });

  leftVolume.addEventListener("input", () => {
    if (leftGainNode) leftGainNode.gain.value = parseFloat(leftVolume.value);
  });

  rightVolume.addEventListener("input", () => {
    if (rightGainNode) rightGainNode.gain.value = parseFloat(rightVolume.value);
  });

  // ======= æ³¢å½¢ã‚’å·¦å³é‡ã­ã¦æç”»ï¼ˆå·®åˆ†ã§è‰²åˆ†ã‘ï¼‰ =======
  function drawWaveformCombined(ctx, leftData, rightData) {
    const width = ctx.canvas.width;
    const height = ctx.canvas.height;
    ctx.clearRect(0, 0, width, height);

    const step = Math.floor(leftData.length / width);
    const amp = height / 2;

    for (let i = 0; i < width; i++) {
      let leftMin = 1.0, leftMax = -1.0;
      let rightMin = 1.0, rightMax = -1.0;

      for (let j = 0; j < step; j++) {
        const lVal = leftData[i * step + j];
        const rVal = rightData[i * step + j];
        if (lVal < leftMin) leftMin = lVal;
        if (lVal > leftMax) leftMax = lVal;
        if (rVal < rightMin) rightMin = rVal;
        if (rVal > rightMax) rightMax = rVal;
      }

      // å·®åˆ†åˆ¤å®š
      const diffMin = Math.abs(leftMin - rightMin);
      const diffMax = Math.abs(leftMax - rightMax);
      const threshold = 0.1; // å·®åˆ†ã®é–¾å€¤ï¼ˆèª¿æ•´å¯ï¼‰

      // è‰²æ±ºå®šé–¢æ•°
      const getColor = (diff) => {
        if (diff < threshold) return "gray"; // ã»ã¼åŒã˜ãªã‚‰ã‚°ãƒ¬ãƒ¼
        // å·®ãŒå¤§ãã„å ´åˆã€å·¦é’ãƒ»å³èµ¤ï¼ˆåˆ†ã‹ã‚Šã‚„ã™ãï¼‰
        return null;
      };

      // ä¸‹é™ãƒ©ã‚¤ãƒ³æç”»
      const colorMin = getColor(diffMin);
      if (colorMin === "gray") {
        ctx.strokeStyle = "gray";
        ctx.beginPath();
        ctx.moveTo(i, amp - leftMin * amp);
        ctx.lineTo(i, amp - rightMin * amp);
        ctx.stroke();
      } else {
        // å·¦é’ç·š
        ctx.strokeStyle = "blue";
        ctx.beginPath();
        ctx.moveTo(i, amp);
        ctx.lineTo(i, amp - leftMin * amp);
        ctx.stroke();
        // å³èµ¤ç·š
        ctx.strokeStyle = "red";
        ctx.beginPath();
        ctx.moveTo(i, amp);
        ctx.lineTo(i, amp - rightMin * amp);
        ctx.stroke();
      }

      // ä¸Šé™ãƒ©ã‚¤ãƒ³æç”»
      const colorMax = getColor(diffMax);
      if (colorMax === "gray") {
        ctx.strokeStyle = "gray";
        ctx.beginPath();
        ctx.moveTo(i, amp - leftMax * amp);
        ctx.lineTo(i, amp - rightMax * amp);
        ctx.stroke();
      } else {
        // å·¦é’ç·š
        ctx.strokeStyle = "blue";
        ctx.beginPath();
        ctx.moveTo(i, amp);
        ctx.lineTo(i, amp - leftMax * amp);
        ctx.stroke();
        // å³èµ¤ç·š
        ctx.strokeStyle = "red";
        ctx.beginPath();
        ctx.moveTo(i, amp);
        ctx.lineTo(i, amp - rightMax * amp);
        ctx.stroke();
      }
    }
  }

  // ======= ã‚¹ãƒšã‚¯ãƒˆãƒ­ã‚°ãƒ©ãƒ ã‚’å·¦å³æ¯”è¼ƒã—å·®ç•°è‰²ä»˜ãã§æç”» =======
  function drawSpectrogramCombined() {
    if (!playing) return;

    const width = spectrogramCanvas.width;
    const height = spectrogramCanvas.height;

    const leftDataArray = new Uint8Array(leftAnalyser.frequencyBinCount);
    const rightDataArray = new Uint8Array(rightAnalyser.frequencyBinCount);

    leftAnalyser.getByteFrequencyData(leftDataArray);
    rightAnalyser.getByteFrequencyData(rightDataArray);

    // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å‡¦ç†ï¼šå·¦ã¸1pxãšã¤ãšã‚‰ã™
    const imageData = spectrogramCtx.getImageData(1, 0, width - 1, height);
    spectrogramCtx.putImageData(imageData, 0, 0);

    // æ–°ã—ã„1åˆ—åˆ†æç”»ï¼ˆä¸Šã‹ã‚‰ä¸‹ã«å‘¨æ³¢æ•°ï¼‰
    for (let y = 0; y < height; y++) {
      // å‘¨æ³¢æ•°binã‚’ä¸Šä¸‹ã§ãƒªãƒ‹ã‚¢ã«ãƒãƒƒãƒ”ãƒ³ã‚°
      const freqIndex = Math.floor(y / height * leftDataArray.length);

      const leftVal = leftDataArray[freqIndex] / 255;
      const rightVal = rightDataArray[freqIndex] / 255;

      const diff = Math.abs(leftVal - rightVal);
      const threshold = 0.15;

      let r = 0, g = 0, b = 0;

      if (diff < threshold) {
        // å·®ãŒå°ã•ã„ â†’ ç°è‰²ã€œç™½ã£ã½ã
        const v = Math.round(((leftVal + rightVal) / 2) * 255);
        r = g = b = v;
      } else {
        if (leftVal > rightVal) {
          // å·¦ãŒå¼·ã„ â†’ é’ç³»
          r = 0;
          g = Math.round(leftVal * 128);
          b = Math.round(leftVal * 255);
        } else {
          // å³ãŒå¼·ã„ â†’ èµ¤ç³»
          r = Math.round(rightVal * 255);
          g = Math.round(rightVal * 50);
          b = Math.round(rightVal * 50);
        }
      }

      spectrogramCtx.fillStyle = `rgb(${r},${g},${b})`;
      spectrogramCtx.fillRect(width - 1, height - y - 1, 1, 1);
    }

    requestAnimationFrame(drawSpectrogramCombined);
  }
</script>
</body>
</html>
